# 第9章

C 的设计思想是, 把函数用作构件块.

## 9.1 复习函数

定义一个函数

## 9.2 ANSI C函数原型

这块讲的是, 如果函数体比较小, 可以在函数调用之前把函数定义及实现写在一起.

## 9.3 递归

### 9.3.1 演示递归

[程序清单 9.6 recur.c](./9/recur.c)

注意这个程序的输出, 先从 Level1 到 Level4 然后 LEVEL3 到 LEVEL1 是降序.

首先, main() 调用了带参数 1 的 `up_and_down` 函数, 执行结果是 `up_and_down()` 中的形式参数 n 的值是 1, 所以打印语句 `#1` 打印 Level 1. 然后, 由于 n 小于 4, `up_and_down()` (第 1 级) 调用实际参数为 `n+1` (或 2) 的 up_and_down() (第 2 级). 于是第 2 级调用中的 n 的值是 2, 打印语句 `#1` 打印 Level 2. 与此类似, 下面两次调用打印的分别是 Level3 和 Level4.

当执行到第 4 级时, n 的值为 4, 所以 if 测试条件为假. `up_and_down` 函数不再调用自己. 第 4 级调动接着执行打印语句 `#2`, 即打印 Level 3, 此时 n 的值是 3. 此时第 4 级调用结束, 控制被传回它的主调函数(即第 3 级调用). 在第 3 级调用中, 执行的最后一条语句是调用 if 语句中的第 4 级调用. 被调用函数(第 4 级调用) 把控制返回在这个位置, 因此第 3 级调用继续执行后面的代码 ...

每级递归的变量 n 都属于本级递归私有. 这从程序输出的地址值可以看出.

如果觉得不好理解, 可以假设有一条函数调用链 -- fun1() 调用 fun2() , fun2() 调用 fun3(), fun3() 调用 fun4. 当 fun4 结束时, 控制传回 fun3(), fun3 结束时控制传回 fun2 ...

### 9.3.2 递归的基本原理

第 1, 每级函数调用都有自己的变量. 也就是说, 第 1 级的 n 和第 2 级的 n 不同, 所以程序创建了 4 个单独的变量, 每个变量名都是 n, 但它们的值各不相同.

第 2, 每次函数调用都会返回一次. 当函数执行完毕后, 控制权将被传回上一级递归. 程序必须按顺序逐级返回递归.

第 3, 递归函数中位于递归调用之前的语句, 均按被调函数的顺序执行. 

第 4, 递归函数中位于递归调用之后的语句, 均按被调用函数相反的顺序执行. 例如, 打印语句 `#2` 位于递归调用之后, 其执行顺序是第 4 级, 第 3 级, 第 2 级 ... 递归调用的这种特性在解决涉及相反顺序的编程问题时很有用.

第 5, 虽然每级递归都有自己的变量, 但是并没有拷贝函数的代码. 程序按顺序执行函数中的代码, 而递归调用就相当于又从头开始执行函数的代码. 除了为每次递归调用创建的变量外, 递归调用非常类似于一个循环语句. 实际上, 递归和循环有时可以互换.

最后, 递归函数必须包含能让递归调用停止的语句. 通常, 递归函数都使用 `if` 或其他等价的测试条件在函数形参等于某特定值时终止递归. 为此, 每次递归调用的形参都要使用不同的值.

### 9.3.3 尾递归

最简单的递归形式是把递归调用置于函数的尾部, 即正好在 return 语句之前. 这种形式的递归被称为尾递归(tail recursion), 因为递归调用在函数的末尾. 尾递归是最简单的递归形式, 因为它相当于循环.

### 9.3.4 递归和倒序计算

*设计一个以二进制形式表示整数的方法*

二进制表示法根据 `2` 的幂来表示数字. 例如, 十进制数 234 实际上是 2X10²+3X10¹+4X10º, 所以二进制数 101 实际是 1X2²+0X2¹+1X2º. 二进制数由 0 和 1 表示.

如何用二进制表示十进制数 5? 在二进制中, 奇数的末尾一定是 1, 偶数的末尾一定是 0, 所以通过 `5 % 2` 即可确定 5 的二进制数的最后一位是 1 还是 0. 一般而言, 对于数字 n, 其二进制的最后一位是 `n % 2`. 因此, 计算的第一位数字实际上是待输出二进制数的最后一位. 这一规律提示我们, 在递归函数的递归调用之前计算 `n % 2`, 在递归调用之后打印计算结果. 这样, 计算的第一个值正好是最后一个打印的值.

要获得下一位数字, 必须把原数除以 2. 这种计算方法相当于在十进制下把小数点左移一位, 如果计算结果是偶数, 那么二进制的下一位就是 0, 如果是奇数, 就是 1. 例如, `5/2` 得 2 (整数除法), 2 是偶数 , 所以下一位二进制就是 0. 到目前为止, 我们已经获得了 01. 继续重复这个过程, 2/2 得1, 1%2 得 1, 所以下一位二进制数是 1. 因此, 我们得到的 5 的等价二进制数是 101. 那么, 程序应该何时停止计算? 当与 2 相除的结果小于 2 时停止计算, 因为只要结果大于或等于 2, 就说明还有二进制位. 每次除以 2 就相当于去掉一位二进制, 直到计算出最后一位位置( 如果不好理解, 可以拿十进制数来做类比: 628%10得8, 因此8就是该数最后一位; 而 628/10 得62, 而62%10得 2 , 所以下一位是2, 以此类推). (*这个做法就是每个数都是由商+余数构成的, 不断除以进制不断逼近*)

[程序清单 9.8 binary.c](./9/binary.c)

### 9.3.5 递归的优缺点

递归的优点: 递归为某些编程问题提供了最简单的解决方案.

缺点: 递归算法会快速的消耗计算机的内存资源.

裴波那契数列定义: 第1个和第2个数字都是1, 而后续的每个数字都是其前两个数字之和.

[斐波那契数列](./9/fibonacci.c)

斐波那契数列的问题

该函数使用了双递归(double recursion), 即函数每一级递归都要调用本身两次. 为了说明这个问题, 假设调用 `Fibonacci(40)`, 这是第 1 级递归调用, 将创建一个变量 n. 然后在该函数中要调用 `Fibonacci()` 两次, 在第 2 级递归中要分别创建两个变量 n. 这两次调用中的每次调用又会进行两次调用, 因此在第 3 级递归中要创建 4 个名为 n 的变量. 所以变量的个数会指数级增长.

## 9.4 编译多源代码文件的程序

### 9.4.1 UNIX, 9.4.2 Linux

下面的命令将编译两个文件并生成一个名为 a.out 的可执行文件:

```c
cc file1.c file2.c
```

另外, 还生成了两个名为 file1.o 和 file2.o 的目标文件. 如果后来改动了 file1.c , 而 file2.c 不变, 可以使用以下命令编译第 1 个文件, 并与第 2 个文件的目标代码合并:

```
cc file1.c file2.o
```

### 9.4.5 使用头文件

把函数原型放在头文件, 就不用在每次使用函数文件时都写出函数的原型, C 标准库就是这么做的, 例如把 I/O 函数的原型放在 stdio.h 中.

另外, 程序中经常用 C 预处理器定义符号常量, 把 `#define` 指令放到头文件, 然后每个源文件中使用 `#include` 指令包含该文件即可. 总之, 把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯.

[程序清单](./9/hotel)





