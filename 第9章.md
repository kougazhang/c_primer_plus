# 第9章

C 的设计思想是, 把函数用作构件块.

## 9.1 复习函数

定义一个函数

## 9.2 ANSI C函数原型

这块讲的是, 如果函数体比较小, 可以在函数调用之前把函数定义及实现写在一起.

## 9.3 递归

### 9.3.1 演示递归

[程序清单 9.6 recur.c](./9/recur.c)

注意这个程序的输出, 先从 Level1 到 Level4 然后 LEVEL3 到 LEVEL1 是降序.

首先, main() 调用了带参数 1 的 `up_and_down` 函数, 执行结果是 `up_and_down()` 中的形式参数 n 的值是 1, 所以打印语句 `#1` 打印 Level 1. 然后, 由于 n 小于 4, `up_and_down()` (第 1 级) 调用实际参数为 `n+1` (或 2) 的 up_and_down() (第 2 级). 于是第 2 级调用中的 n 的值是 2, 打印语句 `#1` 打印 Level 2. 与此类似, 下面两次调用打印的分别是 Level3 和 Level4.

当执行到第 4 级时, n 的值为 4, 所以 if 测试条件为假. `up_and_down` 函数不再调用自己. 第 4 级调动接着执行打印语句 `#2`, 即打印 Level 3, 此时 n 的值是 3. 此时第 4 级调用结束, 控制被传回它的主调函数(即第 3 级调用). 在第 3 级调用中, 执行的最后一条语句是调用 if 语句中的第 4 级调用. 被调用函数(第 4 级调用) 把控制返回在这个位置, 因此第 3 级调用继续执行后面的代码 ...

每级递归的变量 n 都属于本级递归私有. 这从程序输出的地址值可以看出.

如果觉得不好理解, 可以假设有一条函数调用链 -- fun1() 调用 fun2() , fun2() 调用 fun3(), fun3() 调用 fun4. 当 fun4 结束时, 控制传回 fun3(), fun3 结束时控制传回 fun2 ...

### 9.3.2 递归的基本原理

第 1, 每级函数调用都有自己的变量. 也就是说, 第 1 级的 n 和第 2 级的 n 不同, 所以程序创建了 4 个单独的变量, 每个变量名都是 n, 但它们的值各不相同.

第 2, 每次函数调用都会返回一次. 当函数执行完毕后, 控制权将被传回上一级递归. 程序必须按顺序逐级返回递归.

第 3, 递归函数中位于递归调用之前的语句, 均按被调函数的顺序执行. 

第 4, 递归函数中位于递归调用之后的语句, 均按被调用函数相反的顺序执行. 例如, 打印语句 `#2` 位于递归调用之后, 其执行顺序是第 4 级, 第 3 级, 第 2 级 ... 递归调用的这种特性在解决涉及相反顺序的编程问题时很有用.

第 5, 虽然每级递归都有自己的变量, 但是并没有拷贝函数的代码. 程序按顺序执行函数中的代码, 而递归调用就相当于又从头开始执行函数的代码. 除了为每次递归调用创建的变量外, 递归调用非常类似于一个循环语句. 实际上, 递归和循环有时可以互换.

最后, 递归函数必须包含能让递归调用停止的语句. 通常, 递归函数都使用 `if` 或其他等价的测试条件在函数形参等于某特定值时终止递归. 为此, 每次递归调用的形参都要使用不同的值.

### 9.3.3 尾递归

最简单的递归形式是把递归调用置于函数的尾部, 即正好在 return 语句之前. 这种形式的递归被称为尾递归(tail recursion), 因为递归调用在函数的末尾. 尾递归是最简单的递归形式, 因为它相当于循环.





