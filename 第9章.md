# 第9章

C 的设计思想是, 把函数用作构件块.

## 9.1 复习函数

定义一个函数

## 9.2 ANSI C函数原型

这块讲的是, 如果函数体比较小, 可以在函数调用之前把函数定义及实现写在一起.

## 9.3 递归

### 9.3.1 演示递归

[程序清单 9.6 recur.c](./9/recur.c)

注意这个程序的输出, 先从 Level1 到 Level4 然后 LEVEL3 到 LEVEL1 是降序.

首先, main() 调用了带参数 1 的 `up_and_down` 函数, 执行结果是 `up_and_down()` 中的形式参数 n 的值是 1, 所以打印语句 `#1` 打印 Level 1. 然后, 由于 n 小于 4, `up_and_down()` (第 1 级) 调用实际参数为 `n+1` (或 2) 的 up_and_down() (第 2 级). 于是第 2 级调用中的 n 的值是 2, 打印语句 `#1` 打印 Level 2. 与此类似, 下面两次调用打印的分别是 Level3 和 Level4.

当执行到第 4 级时, n 的值为 4, 所以 if 测试条件为假. `up_and_down` 函数不再调用自己. 第 4 级调动接着执行打印语句 `#2`, 即打印 Level 3, 此时 n 的值是 3. 此时第 4 级调用结束, 控制被传回它的主调函数(即第 3 级调用). 在第 3 级调用中, 执行的最后一条语句是调用 if 语句中的第 4 级调用. 被调用函数(第 4 级调用) 把控制返回在这个位置, 因此第 3 级调用继续执行后面的代码 ...

每级递归的变量 n 都属于本级递归私有. 这从程序输出的地址值可以看出.

如果觉得不好理解, 可以假设有一条函数调用链 -- fun1() 调用 fun2() , fun2() 调用 fun3(), fun3() 调用 fun4. 当 fun4 结束时, 控制传回 fun3(), fun3 结束时控制传回 fun2 ...

### 9.3.2 递归的基本原理

第 1, 每级函数调用都有自己的变量. 也就是说, 第 1 级的 n 和第 2 级的 n 不同, 所以程序创建了 4 个单独的变量, 每个变量名都是 n, 但它们的值各不相同.

第 2, 每次函数调用都会返回一次. 当函数执行完毕后, 控制权将被传回上一级递归. 程序必须按顺序逐级返回递归.

第 3, 递归函数中位于递归调用之前的语句, 均按被调函数的顺序执行. 

第 4, 递归函数中位于递归调用之后的语句, 均按被调用函数相反的顺序执行. 例如, 打印语句 `#2` 位于递归调用之后, 其执行顺序是第 4 级, 第 3 级, 第 2 级 ... 递归调用的这种特性在解决涉及相反顺序的编程问题时很有用.

第 5, 虽然每级递归都有自己的变量, 但是并没有拷贝函数的代码. 程序按顺序执行函数中的代码, 而递归调用就相当于又从头开始执行函数的代码. 除了为每次递归调用创建的变量外, 递归调用非常类似于一个循环语句. 实际上, 递归和循环有时可以互换.

最后, 递归函数必须包含能让递归调用停止的语句. 通常, 递归函数都使用 `if` 或其他等价的测试条件在函数形参等于某特定值时终止递归. 为此, 每次递归调用的形参都要使用不同的值.

### 9.3.3 尾递归

最简单的递归形式是把递归调用置于函数的尾部, 即正好在 return 语句之前. 这种形式的递归被称为尾递归(tail recursion), 因为递归调用在函数的末尾. 尾递归是最简单的递归形式, 因为它相当于循环.

### 9.3.4 递归和倒序计算

*设计一个以二进制形式表示整数的方法*

二进制表示法根据 `2` 的幂来表示数字. 例如, 十进制数 234 实际上是 2X10²+3X10¹+4X10º, 所以二进制数 101 实际是 1X2²+0X2¹+1X2º. 二进制数由 0 和 1 表示.

如何用二进制表示十进制数 5? 在二进制中, 奇数的末尾一定是 1, 偶数的末尾一定是 0, 所以通过 `5 % 2` 即可确定 5 的二进制数的最后一位是 1 还是 0. 一般而言, 对于数字 n, 其二进制的最后一位是 `n % 2`. 因此, 计算的第一位数字实际上是待输出二进制数的最后一位. 这一规律提示我们, 在递归函数的递归调用之前计算 `n % 2`, 在递归调用之后打印计算结果. 这样, 计算的第一个值正好是最后一个打印的值.

要获得下一位数字, 必须把原数除以 2. 这种计算方法相当于在十进制下把小数点左移一位, 如果计算结果是偶数, 那么二进制的下一位就是 0, 如果是奇数, 就是 1. 例如, `5/2` 得 2 (整数除法), 2 是偶数 , 所以下一位二进制就是 0. 到目前为止, 我们已经获得了 01. 继续重复这个过程, 2/2 得1, 1%2 得 1, 所以下一位二进制数是 1. 因此, 我们得到的 5 的等价二进制数是 101. 那么, 程序应该何时停止计算? 当与 2 相除的结果小于 2 时停止计算, 因为只要结果大于或等于 2, 就说明还有二进制位. 每次除以 2 就相当于去掉一位二进制, 直到计算出最后一位位置( 如果不好理解, 可以拿十进制数来做类比: 628%10得8, 因此8就是该数最后一位; 而 628/10 得62, 而62%10得 2 , 所以下一位是2, 以此类推). (*这个做法就是每个数都是由商+余数构成的, 不断除以进制不断逼近*)

[程序清单 9.8 binary.c](./9/binary.c)

### 9.3.5 递归的优缺点

递归的优点: 递归为某些编程问题提供了最简单的解决方案.

缺点: 递归算法会快速的消耗计算机的内存资源.

裴波那契数列定义: 第1个和第2个数字都是1, 而后续的每个数字都是其前两个数字之和.

[斐波那契数列](./9/fibonacci.c)

斐波那契数列的问题

该函数使用了双递归(double recursion), 即函数每一级递归都要调用本身两次. 为了说明这个问题, 假设调用 `Fibonacci(40)`, 这是第 1 级递归调用, 将创建一个变量 n. 然后在该函数中要调用 `Fibonacci()` 两次, 在第 2 级递归中要分别创建两个变量 n. 这两次调用中的每次调用又会进行两次调用, 因此在第 3 级递归中要创建 4 个名为 n 的变量. 所以变量的个数会指数级增长.

## 9.4 编译多源代码文件的程序

### 9.4.1 UNIX, 9.4.2 Linux

下面的命令将编译两个文件并生成一个名为 a.out 的可执行文件:

```c
cc file1.c file2.c
```

另外, 还生成了两个名为 file1.o 和 file2.o 的目标文件. 如果后来改动了 file1.c , 而 file2.c 不变, 可以使用以下命令编译第 1 个文件, 并与第 2 个文件的目标代码合并:

```
cc file1.c file2.o
```

### 9.4.5 使用头文件

把函数原型放在头文件, 就不用在每次使用函数文件时都写出函数的原型, C 标准库就是这么做的, 例如把 I/O 函数的原型放在 stdio.h 中.

另外, 程序中经常用 C 预处理器定义符号常量, 把 `#define` 指令放到头文件, 然后每个源文件中使用 `#include` 指令包含该文件即可. 总之, 把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯.

[程序清单](./9/hotel)

## 9.5 查找地址: `&` 运算符

**一元运算符 &**

一元运算符 `&` 给出变量的存储地址. 如果 pooh 是变量名, 那么 `&pooh` 是变量的地址, 可以把地址看作是变量在内存中的位置. 假设有如下语句:

```c
pooh = 24;
```

假设 pooh 的存储地址是 0B76 (PC 地址通常用十六进制形式表示). 那么, 下面的语句:

```
printf("%d%p\n", pooh, &pooh);
```

[程序清单 9.12 locheck.c](./9/ locheck.c)

首先, 两个 pooh 的地址不同, 两个 bah 的地址也不同. 因此, 和前面介绍的一样, 计算机把它们看做 4 个独立的变量. 

其次, 函数调用 `mikado(pooh)` 把实际参数 (main() 中的 pooh 的值) (2) 传递给形式参数 (mikado() 中的 bah). 注意, 这种传递只传递了值. 

这种传递值的行为, 并不是在所有语言中都存在的.

## 9.6 更改主调函数中的变量

有时需要在一个函数中更改其他函数的变量. 例如, 普通的排序任务中交换两个变量的值. 假如要交换两个变量 x 和 y 的值, 简单的思路是:

```
x = y;
y = x;
```

这完全不起作用, 因为执行到第 2 行时,  x 的原始值已经被 y 的原始值替换了. 因此要多写一行代码, 存储 x 的原始值:

```c
temp = x; // temp 存储了 x 原来的值
x = y;
y = temp;
```

## 9.7 指针简介

指针? 从根本上看, 指针(pointer) 是一个值为内存地址的变量(或数据对象). 正如 char 类型变量的值是字符, int 类型变量的值是整数, 指针变量的值是地址. 

假设一个指针变量名是 ptr, 可以编写如下语句:

```c
ptr = &pooh; // 把 pooh 的地址赋给 ptr
```

对于这条语句, 我们说 ptr "指向" pooh. ptr 和 &pooh  的区别是 ptr 是变量, 而 &pooh 是常量. 或者, ptr 是可修改的左值, 而 &pooh 是右值.

### 9.7.1 间接运算符: `*`

假设已知 `ptr` 指向 bah, 如下所示:

```c
ptr = &bah;
```

然后使用间接运算符 `*` (indirection operator) 找出存储在 bah 中的值, 该运算符有时也称为解引用运算符. 不要把间接运算符和二元乘法运算符(`*`)混淆.

```c
val = *ptr; // 找出 ptr 指向的值
```

语句 `ptr = &bah` 和 `val = *ptr` ; 放在一起相当于下面的语句:

```c
val = bah;

// 相当于以下两个步骤.
// 把 ptr 指向 bah 的地址
ptr = &bah; 
// 把 ptr 对应的值取出来赋给 val
val = *ptr;
```

由此可见, 使用地址和间接运算符可以间接完成上面这条语句的功能, 这也是 "间接运算符" 名称的由来.

### 9.7.2 声明指针

因为声明指针变量时必须指定指针所指向变量的类型, 因为不同的变量类型占用不同的存储空间, 一些指针操作要求知道操作对象的大小. 另外, 程序必须知道存储在指定地址上的数据类型.

下面是一些指针的声明示例:

```c
int *pi; // pi 是指向 int 类型变量的指针
char *pc; // pc 是指向 char 类型变量的指针
float *pf, *pg // pf, pg 都是指向 float 类型变量的指针
```

类型说明符表明了指针所指向对象的类型, 星号(*) 表明声明的变量是一个指针. `int *pi` 声明的意思是 `pi` 是一个指针, `*pi` 是 int 类型.

`*` 和指针名之间的空格可有可无. 通常, 程序员在声明时使用空格, 在解引用变量时省略空格.

pc 指向的值 (`*pc`) 是 char 类型. pc 本身是什么类型? 我们描述它的类型是 "指向 char 类型的指针". Pc 的值是一个指针, 在大部分系统内部, 该地址由一个无符号整数表示. 但是, 不要把指针认为是整数类型. 一些处理整数的操作不能用来处理指针, 反之亦然.

### 9.7.3 使用指针在函数间通信

[程序清单 9.15 swap3.c](./9/swap3.c) 在函数中使用了指针参数.

第 1 种形式适用于函数参数参与计算

```c
int function1(int num)
```

第 2 种形式一般用于要改变函数参数

```c
int function2(int num)
```

编写程序时, 可以认为变量有两个属性: 名称和值 (还有其他性质, 如类型, 暂不讨论). 计算机编译和加载程序后, 认为变量也有两个属性: 地址和值. 地址就是变量在计算机内部的值. 地址就是变量在计算机内部的名称.

在许多语言中, 地址都归计算机管, 对程序员隐藏. 然而在 C 中, 可以通过 `&` 运算符访问地址, 通过 `*` 运算符获得地址上的值. 例如, `&barn` 表示 `barn` 的地址, 使用函数名即可获得变量的数值. 例如, `printf("%d\n", barn)` 打印 `barn` 的值, 使用 `*` 运算符即可获得存储在地址上的值. 如果 `pbarn = &barn` , 那么 `*pbarn` 表示的是存储在 `&barn` 地址上的值.

简而言之, 普通变量把值作为基本量, 把地址作为通过 `&` 运算符获得的派生量, 而指针变量把地址作为基本量, 把值作为通过 `*` 运算符获得的派生量.

## 9.8 关键概念

把大型程序组织成若干函数非常有用, 甚至很关键.

## 9.11 编程练习







