# 第 8 章

## 8.1 单字符 I/O 

`getchar()` 从标准输入获取一个字符, `putchar()` 打印一个字符到标准输出.

## 8.2 缓冲区

*输入缓冲区* 是指用户输入字符后程序不能立即使用该字母, 必须等用户按下 Enter 键后才能使用. 用户输入的字符被收集并存储在一个被称为缓冲区 (`buffer`) 的临时存储区.

为什么要有缓冲区?

+ 把若干字符当做一个块进行传输比逐个发送这些字符节省时间.
+ 如果用户打错字符, 可以直接通过键盘修正

*缓冲分类*

+ 完全缓冲 `I/O`: 完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区 (内容被发送至目的地), 通常出现在文件输入中.
+ 行缓冲 I/O: 是指出现换行符时刷新缓冲区. 键盘输入通常是行缓冲输入.

## 8.3 结束键盘输入

### 8.3.1 文件, 流和键盘输入

使用标准 I/O 包时, 不必考虑不同文件系统之间的差异. 可以用 `if (ch == '\n')` 检查换行符. 即使系统实际用的是回车符和换行符的组合来标记行末尾, I/O 函数会在两种表示法之间相互转换.

从概念上看, C程序处理的是流而不是直接处理文件. 流(stream) 是一个实际输入或输出映射的理想化数据流. 这意味着不同属性和不同种类的输入, 由属性更统一的流来表示. 于是, 打开文件的过程就是把流与文件相关联, 而且读写都通过流来完成.

### 8.3.2 文件结尾

计算机操作系统要以某种方式判断文件的开始和结束. 检查文件结尾的一种方法是, 在文件末尾放一个特殊的字符标记文件结束. CP/M, IBM-DOS 和 MS-DOS 的文本文件都曾使用过这种方法. 如今, 这些操作系统可以使用内嵌的 `Ctrl+Z` 字符来标记文件结尾. 现在也有一些其他的选择, 例如记录文件的大小. 所以现在的文本文件不一定有嵌入的 Ctrl + Z, 但是如果有, 该操作系统会将其视为一个文件结尾标记.

散文原文:

```
Ishphat the robot
slid open the hatch
and shouted his challenge.
```

文件存储:

```
Ishphat the robot\nslid open the hatch\nand shouted his challenge.\n^Z
```

现在操作系统使用存储文件大小的信息, 如果文件有 3000 字节, 程序在读到 3000 字节时便达到文件的末尾.

无论操作系统实际使用何种方法检查文件结尾, 在 C语言中, 用 `getchar()` 读取文件检测到文件结尾时将返回一个特殊的值, 即 `EOF(end of file 的缩写)`. EOF 定义在 stdio.h 文件中:

```c
#define EOF (-1)
```

为什么是 -1? 因为 getchar() 函数的返回值通常都介于 0~127, 这些值对应标准字符集. 但是, 如果系统能识别扩展字符集, 该函数的返回值在 0~255 之间. 无论哪种情况, -1 都不对应任何字符. 所以可以使用 -1 标记文件结尾. (*看来不支持 UTF-8*)

由于大部分系统都可以通过键盘模拟文件结尾条件, 所以可以使用文件结尾作为输入时程序中断的标志.

[程序清单 echo_eof.c](./8/echo_eof.c)

一些系统可以使用 Ctrl + D 传输文件结尾信号. 还有的系统把 Ctrl + Z 作为文件结尾的符号.

## 8.4 重定向和文件

### 8.4.1 UNIX, Linux 和 DOS 重定向

**1. 重定向输入**

`<` 符号是重定向运算符, 该运算符使 words 文件与 stdin 流相关联, 把文件中的内容导入 echo_eof 程序. `echo_eof` 程序本身并不知道输入的内容是来自文件还是键盘, 它只知道这是需要导入的字符流, 所以它读取这些内容并把字符逐个打印在屏幕上, 直至读到文件结尾. 因为 C 把文件和 I/O 设备放在一个层面, 所以文件就是现在的 I/O 设备.

```c
echo "hello world" > words
./a.out < words
// hello world
```

**2. 重定向输出**

```
./a.out < words > stdout
cat stdout 
// hello world
```

**3. 组合重定向**

重定向输入和重定向输出可以组合使用. 并且注意, 命令与重定向运算符的顺序无关:

```shell
// 使用 < 把文件内容重定向输入到 a.out
// 使用 > 把 a.out 的输出重定向到 stdout
./a.out < words > stdout
```

由于命令与重定向运算符的顺序无关, 所以下行也起作用:

```shell
./a.out > stdout < words
```

**4. 重定向运算符的原则**

重定向运算符连接一个可执行程序(包括标准操作系统命令) 和一个数据文件, 不能用于连接一个数据文件和另一个数据文件, 也不能用于连接一个程序和另一个程序.

使用重定向运算符不能读取多个文件的输入, 也不能把输出定向至多个文件.

**5. 其他运算符**

+ `>>` 运算符, 可以把数据添加到现有文件的末尾.
+ `|` 运算符, 能把一个文件的输出连接到另一个文件的输入.

## 8.5 创建更友好的用户界面

### 8.5.1 使用缓冲输入

pass

## 8.11 编程练习



